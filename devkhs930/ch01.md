# 1. 도메인 모델 시작

## 1.1도메인
개발자 입장에서 온라인서점은 구현해야할 대상이 된다.  
온라인 서점 소프트웨어는 온라인으로 책을 파는데 필요한 **상품조회**, **구매**, **결제**, **배송 추적** 등의 기능을 제공한다.  
이때 온라인 서점 소프트웨어로 **해결하려고 하는 문제 영역**이 도메인이다.  

## 하위 도메인
![](../image/devksh930-도메인.png)  
한 도메인은 다시 하위 도메인으로 나뉘어 진다.
- 카탈로그 : 고객에게 구매할수 있는 상품목록 제공
- 주문 : 고객의 주문을 처리
- 혜택 : 특별할인과 같은 서비스 제공
- 배송 : 고객에게 구매한 상품을 전달하는 일련의 과정 처리

하위 도메인 들은 다른 하위 도메인들과 연동하여 완전한 기능을 제공하게 되는데    
고객이 주문을 하게 된다면 주문 -> 결제 -> 배송 --> 혜택 등의 도메인들과 상호작용을 하게 된다.  
온라인서점을 위한 도메인(특정 도메인)이라고 해서 하위도메인의 모든 기능을 이용하는 것이 아닌   
배송, 결제등과 같은 일부기능은 자체 시스템으로 구현하고 나머지기능은 외부 업체의 시스템을 이용한다  


```
하위 도메인 도메인 마다 고정된것이 아니다 상황에 따라 하위도메인을 구성한다
```
### 예시
- 소규모 업체는 엑셀과 같은 도구를 이용해 정산 처리를 한다
- 대형장비를 파는 곳은 온라인으로 카탈로그를 제공하고 주문서 받는정도만 필요한다.



## 1.2 도메인 전문가와 개발자간의 지식 공유
- 개발자는 개발에 앞서 도메인 요구 사항에 대한 올바른 이해를 필요로 한다.
- 요구사항을 올바르게 이해하지 못하면  쓸모가 없거나 유용함이 떨어지는 시스템을 만들 가능성이 높아진다
- 개발자는 도메인 전문가와 직접 대화해 정보의 왜곡을 최소화 한다
- 개발자는 도메인 전문가 만큼은 아니더라도 도메인지식을 갖춰야한다.

## 1.3 도메인 모델 
도메인 모델이란 특정 도메인을 개념적으로 표현한것이다. 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 지식을 공유 하는데 도움이 된다.  
도메인 모델을 표현할 때 클래스 다이어그램,상태다이어그램, UML등의 표기법만 사용해야 하는것이 아닌 구현 기술에 맞는 모델을 통해 도메인 모델을 나타내는 것이 중요하다.

## 1.4 도메인 모델 패턴
#### 일반적인 애플리케이션의 아키텍처
- 사용자 인터페이스 또는 표현 계층(presentation) : 사용자의 요청을 처리하고 정보를 보여준다(사용자는 소프트웨어 사용자 뿐만 아니라 외부시스템일수도 있음)
- 응용 계층(Application) : 사용자가 요청한 기능을 실행 비즈니스로직을 직접 구현하지 않으며 도메인 계층을 조합해 기능 실행
- 도메인 : 시스템이 제공할 도메인 규칙을 구현
- 인프라스트럭쳐(Infrastructure) : 데이터베이스나 메시징시스템등 외부 시스템과 연동을 처리

도메인 모델 패턴은 아키텍처 상의 도메인 계층을 객체 지향 기법으로 구현 하는 패턴을 이야기한다(`엔터프라이즈 애플리케이션 아키텍처 패턴-마틴파울러`)

#### 예제 - 출고전에 배송지를 변경할수 있다, 주문취소는 배송전에만 할수있다
```java
public class Order{
    private OrderState state;
    private ShippingInfo shippingInfo;
    
    public void changeShippingInfo(ShippingInfo newShippingInfo){
        if (!state.isShippingChangeble()) {
            throw new IllegalStateException("can't change shipping in " + state);
        }
        this.shippingInfo = newShippingInfo;
    }
}

public enum OrderState{
    PAYMENT_WAITING{
        public boolean isShippingChangeble(){
            return true;
        }
    },
    PREPARING{
        public boolean isShippingChangeble(){
            return true;
        }
    },
    SHIPPED, DELIVERING, DELIVERY_COMPLETE;
    public boolean isShippingChangeble(){
        return false;
    }
}
```
- 주문 기능의 일부를 도메인 모델패턴으로 구현
- 주문상태를 표현하는 OrderState는 배송상태를 변경할수 있는지에 대한여부를 검증하는 `isShippingChangeble()` 메서드를 구현 하고 있다.
- 핵심 기능을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜주고 변경내용을 반영할수 있다.


## 1.5 도메인 모델 도출
- 개발하기 앞서 도메인에 대한 이해 없이 개발을 시작하지는 못한다. 기획서, 유스케이스, 사용자 스토리 등과 같은 요구사항과  
관련자와의 대화를 통해 도메인에 대해 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 개발을 진행할 수 있다.
- 도메인 모델링시 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.
- 요구사항을 통해서 만든 도메인 모델은 화이트보드나 위키와 같은 도구를 사용해 누구든 쉽게 접근할 수 있도록 해야 한다.
#### 문서화
문서화를 하는 주된 이유는 지식을 공유하기 위해서 이다. 코드를 보면서 도메인에 대해 깊게 이해하게 되므로 코드 자체도 문서화의 일부 이다.  
도메인 관점에서 코드가 도메인을 잘 표현하도록 해야 코드의 가독성이 높아지고 문서로서의 코드가 의미를 갖는다.

## 1.6 엔티티와 벨류
도메인 모델은 크게 '엔티티', '벨류'로 구분이 가능하다.

#### 엔티티 
- 엔티티의 가장 큰 특징은 식별자를 가진다.
- 엔티티 객체마다 식별자는 고유하다.
  - 예: 주문번호(주문번호는 주문마다 다름 객체를 식별할수 있는 조건이 된다.)
- 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 식별자는 유지된다.(식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.)

엔티티의 식별자를 생성하는 시점은 도메인의 특징과 사용하는 기술에 따라 달라진다.  
식별자를 생성하는 방법은 여러가지가 있다.
- 특정 규칙에 따라 생성
- UUID나 Nano ID 같은 고유 식별자 생성기 사용
- 값을 직접 입력
- 일련번호 사용(시퀀스나 DB의 자동증가 컬럼 사용)

#### 벨류타입
- 밸류타입은 엔티티처럼 식별자를 가지지 않지만 값으로 표현 되는 객체를 벨류타입 객체라고 한다.
- 밸류객체의 데이터를 변경할때는 기존 데이터를 변경하기 보다는 변경한 데이터를 가지는 새로운 밸류 객체 방식을 선호한다
- 만약 값객체가 불변타입이 아니라면 참조 투명성과 관련된 문제가 발생한다.
```java
Money price = new Money(1000);
OrderLine line = new OrderLine(producet, price, 2); ->[price=1000, quantity=2, amounts=2000]
price.setValue(2000);                               ->[price=2000, quantity=2, amounts=2000]
```
#### 참조 투명성 문제 해결
```java
public OrderLine(Product product, Money price, int quantity){
    this.product = product;
    this.price = new Money(price.getValue);   ---> price 파라미터가 변경될 때 발생하는 문제를 해결하기 위해 복사본생성
    ...
}
```

#### 엔티티 식별자와 밸류 타입
- 엔티티 식별자의 실제 데이터는 String과 같은 문자열로 구성된 경우가 많다.
- 식별자의 타입으로 `String` 대신 `OrdeNo` 같은 밸류타입을 활용하면 타입을 통해 해당 필드가 주문번호라는 것을 명시적으로 알수 있다.

#### 도메인 모델에 set메서드 넣지 않기
- 객체를 생성할때 습관적으로 get/set 메서드를 넣는다
- set메서드는 객체가 불완전하게 사용되게 한다. 이는 필드값만 변경하고 끝나기 때문에 상태변경과 관련된 도메인 지식이 사라진다.
- 생성시점에 필요한 것을 객체에게 전달해주고 `completePayment()`등과 같은 메서드로 상태를 변경하는 것이 자연스럽다.
- private set메서드는 객체 내부에서 값을 변경하기 위해 사용하므로 크게 문제가 되지 않는다.
- set메서드를 구현해야할 특별한 이유가 존재하지 않는다면 불변타입의 장점을 가질수 있도록 밸류타입은 불변으로 구현해야한다.